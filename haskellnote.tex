\documentclass[platex,a5paper,twoside,fleqn,draft]{jsbook}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsfonts,amssymb,amsmath}
\usepackage{latexsym}
\usepackage{fancybox}
\usepackage{MnSymbol}
\usepackage{stmaryrd}
\usepackage{manfnt}
\usepackage{bm}
% \usepackage{tikz}
% \usetikzlibrary{graphs}
\usepackage{haskellstyle}

\usepackage{geometry}
\usepackage{ascmac}

\title{Haskell Notes v.0}
\author{Ichi Kanaya}
\date{2025}

\newcommand{\keyword}[1]{\textgt{\textbf{#1}}}
\newcommand{\tobewritten}[1]{\begin{screen}\textbf{TK.} {#1}\end{screen}}

\begin{document}

\maketitle

\section{Haskell}

\tobewritten{Haskellについて．}

\section{変数}

変数$x$に値を代入するには次のようにする．\footnote{\haskell では \verb|x = 1| と書く．}
\begin{equation}
x=1
\label{eq:x-equal-one}
\end{equation}
変数という呼び名に反して，変数の値は一度代入したら変えられない．そこで変数に値を代入するとは呼ばずに，変数に値を\keyword{束縛}するという．式\eqref{eq:x-equal-one}の右辺のように数式にハードコードされた値を\keyword{リテラル}と呼ぶ．

リテラルや変数には\keyword{型}がある．型は数学者の\keyword{集合}と似た意味で，整数全体の集合$\mathTypeInt$に相当する\keyword{整数型}や，実数全体の集合$\mathTypeReal$に相当する\keyword{浮動小数点型}がある．以下，誤解のおそれがない限り整数型を$\mathTypeInt$で，浮動小数点型を$\mathTypeReal$で表す．\footnote{\haskell ではそれぞれ \verb|Int| および \verb|Double| を用いる．}

数学者は変数$x$が整数であることを$x\in\mathTypeInt$と書くが，本書では$x\mathTypeIs\mathTypeInt$と書く．これは記号$\in$を別の用途に用いるためである．\footnote{\haskell では \verb|x :: Int| と書く．}

変数の値がいつでも変化しないことを\keyword{参照透過性}と呼ぶ．プログラマが変数の値を変化させたい，つまり\keyword{破壊的代入}を行いたい理由はユーザ入力，ループ，例外，内部状態の変化，大域ジャンプ，継続を扱いたいからであろう．しかし，後に見るようにループ，例外，内部状態の変化，大域ジャンプ，継続に変数の破壊的代入は必要ない．ユーザ入力に関しても章を改めて取り上げる．

本書では変数名を原則1文字として，イタリック体で表し，$w,x,y,z$のような$n$以降のアルファベットを使う．

\section{関数}

整数$x$に$1$を足す\keyword{関数}$f$は次のように定義できる．\footnote{\haskell では \verb|f x = x+1| と書く．}
\begin{equation}
fx=x+1
\end{equation}
ここに$x$は関数$f$の引数である．引数は括弧でくるまない．

本書では関数名を原則1文字として，イタリック体で表し，$f,g,h$のようにアルファベットの$f$以降の文字を使う．ただし有名な関数についてはローマン体で表し，文字数も2文字以上とする．たとえば$\sin$などの三角関数や指数関数がそれにあたる．

変数$x$に関数$f$を\keyword{適用}する場合は次のように書く．ここでも引数を括弧でくるまない．\footnote{\haskell では \verb|z = f x| と書く．}
\begin{equation}
z=fx
\end{equation}

関数$f$が引数をふたつ取る場合は，次のように書く．\footnote{\haskell では \verb|z = f x y| と書く．}
\begin{equation}
z=fxy
\end{equation}
なお$fxy$は$(fx)y$と解釈される．前半の$(fx)$は1引数の関数とみなせる．2引数関数を連続した1引数関数の適用とみなす考え方を，関数の\keyword{カリー化}と呼ぶ．

\tobewritten{有名な関数，実数編．}

\section{関数合成}

関数$f$と関数$g$を連続して使いたい場合
\begin{equation}
z=g(fx)
\end{equation}
とするところであるが，事前に関数$f$と関数$g$を\keyword{合成}しておきたいことがある．

関数の合成は次のように書く．\footnote{\haskell では \verb|k = g . f| と書く．}
\begin{equation}
k=g\mathCompose f
\end{equation}
関数の連続適用$g(fx)$と合成関数の適用$(g\mathCompose f)x$は同じ結果を返す．

関数合成演算子$\mathCompose$は以下のように\keyword{左結合}する．
\begin{align}
k&=h\mathCompose g\mathCompose f\\
&=\left(h\mathCompose g\right)\mathCompose f\\
\end{align}

関数適用のための特別な演算子$\mathApply$があると便利である．演算子$\mathApply$は関数合成演算子よりも優先順位が低い．例を挙げる．\footnote{\haskell では \verb|z = h $ (g . f) x| と書く．}
\begin{align}
z&=h\mathApply(g\mathCompose f)x\\
&=h\left((g\mathCompose f)x\right)
\end{align}

\section{IOサバイバルキット1}

プログラムとは合成された関数である．多くのプログラミング言語では，プログラムそのものにmainという名前をつける．本書では「\keyword{IOモナド}」の章で述べる理由によって，main関数をスラント体で$\mathMain$と書く．

実用的なプログラムはユーザからの入力を受け取り，関数を適用し，ユーザへ出力する．\haskell ではユーザからの1行の入力を$\mathGetLine$で受け取り，変数の値を$\mathPrint$で書き出せる．ここに$\mathGetLine$と$\mathPrint$は関数（ファンクション）ではあるが，特別に「\keyword{アクション}」とも呼ぶ．関数$\mathMain$もアクションである．

引数$x$の1.5乗を求める関数$f$は次のように定義できる．\footnote{\haskell では \verb|f x = x ** 1.5| と書く．}
\begin{equation}
fx=x^{1.5}
\end{equation}
ユーザからの入力に関数$f$を適用してユーザへ出力するプログラムを\haskell で書くと次のようになる．\footnote{\haskell では \verb|main = print . f . read =<< getLine| と書く．}
\begin{equation}
\mathMain
=\mathPrint\mathCompose f\mathCompose\mathRead\mathBind\mathGetLine
\label{eq:first-main}
\end{equation}
% \begin{equation}
%  \textsl{main}=\textsl{print}\mathCompose f\mathBind(\mathrm{read}\mathFMap\textsl{getLine}\mathTypeIs{\mathFunctorTypeGeneral{\textbf{IO}}{\mathTypeInt}})
% \end{equation}
ここに関数$\mathRead$は\keyword{文字列}であるユーザ入力を数に変換する関数である．また演算子$\mathBind$は新たな関数合成演算子で，アクションとアクションを合成するための特別な演算子である．詳細は「\keyword{モナド}」の章で述べる．

式\eqref{eq:first-main}は「$\mathMain$とは$\mathGetLine$した結果を$\mathRead$して$f$して$\mathPrint$するものである」とも読める．そのため\haskell はどうしても手続き的に書きたいプログラマのために，以下のようなシンタックスシュガーを用意している．
\begin{verbatim}
f x = x ** 1.5
main = do
  line <- getLine
  let x = read line
  let y = f x
  print y
\end{verbatim}
このような書き方は「\keyword{do記法}」の章で述べる．

\section{ラムダ}

関数とは，変数名に束縛された\keyword{ラムダ式}である．ラムダ式は次のように書く．\footnote{\haskell では \verb|f = \x -> x+1| と書く．}
\begin{equation}
f=\mathLambda{x}{x+1}
\end{equation}

本書では無名変数$\mathAnonymousParameter$を用いた以下の書き方も用いる．\footnote{無名変数は\haskell には無いが，代わりに「セクション」という書き方ができる．式$(\mathAnonymousParameter+1)$は\haskell では\verb|(+1)| と書く．}
\begin{align}
f&=\left(\mathAnonymousParameter+1\right)\\
&=\mathLambda{x}{x+1}
\end{align}

無名変数が2回以上登場した場合は，その都度新しいパラメタを生成する．たとえば次のとおりである．\footnote{\haskell では \verb|f = (+)| と書く．}
\begin{align}
f&=\mathAnonymousParameter+\mathAnonymousParameter\\
&=\mathLambda{x}{(\mathLambda{y}{x+y})}
\end{align}

\section{ローカル変数}

関数内で\keyword{ローカル変数}を使いたい場合は以下のように行う．\footnote{\haskell では \verb|z = let {y = 1} in x+y| と書く．\verb|let| 節内の式がひとつの場合，中括弧は省略可能である．式が複数になる場合は \verb|;| で区切る．}
\begin{equation}
z=\mathLetIn{y=1}{x+y}
\label{eq:let-in}
\end{equation}
ローカル変数はラムダ式のシンタックスシュガーである．式\eqref{eq:let-in}は次の式と等価である．
\begin{equation}
z=(\mathLambda{y}{x+y})1
\end{equation}

ローカル変数の定義は次のように後置できる．\footnote{\haskell では \verb|z = x+y where {y = 1}| と書く．\verb|where| 節内の式が一つの場合，中括弧は省略可能である．式が複数になる場合は \verb|;| で区切る．}
\begin{equation}
z=x+y\mathWhere{y=1}
\end{equation}

\section{クロージャ}

ラムダ式を返す関数は，ラムダ式内部に値を閉じ込めることができる．たとえば
\begin{equation}
fn=\mathLambda{x}{n+x}
\end{equation}
のように関数を定義して良い．関数$f$に引数$n$を与えると，新たな1引数関数が得られる．例を挙げる．
\begin{align}
n&=3\\
g&=fn
\end{align}
この例では，関数$g$の中に値$n=3$が閉じ込められているため$g1$は$4$と評価される．値を閉じ込めたラムダ式を\keyword{クロージャ}と呼ぶ．

\section{型}

すべての変数，関数には\keyword{型}がある．代表的な型には整数型，浮動小数点型，ブール型，文字型がある．整数型を$\mathTypeInt$で，浮動小数点型を$\mathTypeReal$で表すことはすでに述べたとおりである．

\haskell には2種類の整数型がある．ひとつは\keyword{固定長整数型}で，もうひとつは\keyword{多倍長整数型}である．\haskell では前者を \verb|Int| で，後者を \verb|Integer| で表す．多倍長整数型はメモリの許す限り巨大な整数を扱えるので，整数全体の集合に近いのであるが，本書では$\mathTypeInt$と書いて固定長整数型を意味することにする．

浮動小数点型には\keyword{単精度浮動小数点型}と\keyword{倍精度浮動小数点型}があり，\haskell では前者を \verb|Float| で，後者を \verb|Double| で表現するが，単精度浮動小数点型はめったに用いられないため，今後$\mathTypeReal$と書けば倍精度浮動小数点型の意味とする．

ブール型は論理値$\mathTrue$または$\mathFalse$のいずれかしか値をとれない型で，今後$\mathTypeBool$と書く．\footnote{\haskell ではブール型を \verb|Bool| と書く．}

本書では対応する，あるいは近い数学概念がある場合，型名をブラックボード体1文字で書く．文字型のように対応する数学概念がない場合はボールドローマン体を用いる．文字型は$\mathTypeChar$とする．\footnote{\haskell ではUnicode文字型を \verb|Char| と書く．}

変数$x$の型が$\mathTypeInt$のとき，以下のように\keyword{型注釈}を書く．\footnote{\haskell では \verb|x :: Int| と書く．}
\begin{equation}
x\mathTypeIs\mathTypeInt
\end{equation}

1引数関数の型は次のように注釈できる．\footnote{\haskell では \verb|f :: Int -> Int| と書く．}
\begin{equation}
f\mathTypeIs\mathTypeFunction{\mathTypeInt}{\mathTypeInt}
\end{equation}
ここで関数$f$は整数型の引数をひとつとり，整数型の値を返す．\footnote{正確には$\rightarrow$は型コンストラクタである．}

2引数関数の方は次のように注釈できる．\footnote{\haskell では \verb|f :: Int -> Int -> Int| と書く．}
\begin{equation}
f\mathTypeIs\mathTypeFunctionII{\mathTypeInt}{\mathTypeInt}{\mathTypeInt}
\end{equation}
ここで関数$f$は整数型の引数をふたつとり，整数型の値を返す．型$\mathTypeFunctionII{\mathTypeInt}{\mathTypeInt}{\mathTypeInt}$は$\mathTypeFunction{\mathTypeInt}{\left(\mathTypeFunction{\mathTypeInt}{\mathTypeInt}\right)}$と解釈される．

$(\mathTypeFunction{\mathTypeInt}{\mathTypeInt})$型の関数を受け取り，$(\mathTypeFunction{\mathTypeInt}{\mathTypeInt})$型の関数を返す関数は次の型を持つ．\footnote{\haskell では以下のように書く．
\begin{footcode}
      f :: (Int -> Int) -> (Int -> Int)
\end{footcode}}
\begin{equation}
f\mathTypeIs\mathTypeFunction{\left(\mathTypeFunction{\mathTypeInt}{\mathTypeInt}\right)}
  {\left(\mathTypeFunction{\mathTypeInt}{\mathTypeInt}\right)}
\end{equation}
なお後半の括弧は省略可能なので
\begin{equation}
f\mathTypeIs\mathTypeFunction{\left(\mathTypeFunction{\mathTypeInt}{\mathTypeInt}\right)}
  {\mathTypeFunction{\mathTypeInt}{\mathTypeInt}}
\end{equation}
と書いても良い．



\section{条件}

\keyword{条件分岐}は次のように書く．\footnote{\haskell では \verb|z = if x>0 then x else -x| と書く．}
\begin{equation}
z=\mathIf{x>0}{x}{-x}
\end{equation}

条件分岐の代わりに以下のような\keyword{パターンマッチ}も使える．\footnote{\haskell では以下のように書くのが一般的である．
\begin{footcode}
      f = case x of 1 -> 1
                    _ -> 0
\end{footcode}}
\begin{equation}
f=\mathCase{x}{1}{1}{\mathAny}{0}
\end{equation}
この場合$x\mathCompareEq1$ならば$f$は$1$を，そうでなければ$f$は$0$を返す．ここに$\mathAny$はすべてのパターンに一致する記号である．パターンマッチは上から順に行われる．

関数定義にもパターンマッチを使える．\footnote{\haskell では次のように書く．
\begin{footcode}
      f 1 = 1
      f _ = 0
\end{footcode}}
\begin{equation}
\mathPatternMatch{f1}{1}{f\mathAny}{0}
\end{equation}

関数定義には次のように\keyword{ガード}と呼ばれる条件を付与することができる．\footnote{\haskell では次のように書く．
\begin{footcode}
      f x | x > 0     = x
          | otherwise = -x
\end{footcode}}
\begin{equation}
\mathPatternMatchConditional{fx}{x>0}{x}{\mathOtherwise}{-x}
\end{equation}
ここに$\mathOtherwise$は$\mathAny$の別名である．

\section{関数の再帰呼び出し}

関数は再帰的に呼び出せる．$n\ge0$を前提とすると，$n$番目のフィボナッチ数を計算する関数$\mathFib$を次のように定義できる．\footnote{\haskell では次のように書く．ただし\haskell には符号なし整数型がないために \verb|n| が正であることを別に担保する必要がある．またこのコードは無駄な再帰呼び出しを行っており実用的ではない．
\begin{footcode}
      fib 0 = 0
      fib 1 = 1
      fib n = fib (n-1) + fib (n-2)
\end{footcode}}
\begin{equation}
\left\{
\begin{aligned}
\mathFib 0&=0\\
\mathFib 1&=1\\
\mathFib n&=\mathFib(n-1)+\mathFib(n-2)
\end{aligned}
\right.
\end{equation}

\section{タプル}

複数の変数をまとめてひとつの\keyword{タプル}にすることができる．例を挙げる．\footnote{\haskell では \verb|z = (x, y)| と書く．}
\begin{equation}
z=(x,y)
\end{equation}

タプルの型は，要素の型をタプルにしたものである．例えば$\mathTypeInt$が2個からなるタプルの型は次のようになる．\footnote{In \haskell, \verb|z :: (Int, Int)|.}
\begin{equation}
z\mathTypeIs(\mathTypeInt,\mathTypeInt)
\end{equation}

要素を含まないタプルを\keyword{ユニット}と呼ぶ．ユニットは次のように書く．\footnote{\haskell では \verb|z = ()| と書く．}
\begin{equation}
z=()
\end{equation}

ユニットの型は\keyword{ユニット型}で，型注釈を次のように書く．\footnote{\haskell では \verb|z :: ()| と書く．}
\begin{equation}
z\mathTypeIs()
\end{equation}

\section{リスト}

任意の型について，その型の要素を並べた列を\keyword{リスト}と呼ぶ．

ある変数がリストであるとき，その変数がリストであることを忘れないように$\mathList{x}$と小さく$\mathrm{s}$を付けることにする．

\keyword{空リスト}は次のように定義する．\footnote{\haskell では \verb|xs = []| と書く．}
\begin{equation}
\mathList{x}=\mathEmptyList
\end{equation}
任意のリストは次のように$:$演算子を用いて構成する．
\begin{equation}
\mathList{x}=x_0:x_1:x_2:\dots:\mathEmptyList
\end{equation}

リストの型はその構成要素の型をブラケットで包んで表現する．\footnote{\haskell では \verb|xs :: [Int]| と書く．}
\begin{equation}
\mathList{x}\mathTypeIs\mathTypeList{\mathTypeInt}
\end{equation}

リストは次のように構成することもできる．\footnote{\haskell では \verb|xs = [1, 2..100]| と書く．}
\begin{equation}
\mathList{x}=\mathMakeList{1,2,\dots,100}
\end{equation}
なお次のような\keyword{無限リスト}を構成しても良い．\footnote{\haskell では \verb|xs = [1, 2..]| と書く．}
\begin{equation}
\mathList{x}=\mathMakeList{1,2,\dots}
\end{equation}

リストとリストをつなぐ場合は\keyword{リスト結合演算子}$\mathListConcat$を用いる．\footnote{\haskell では \verb|zs = xs ++ ys| と書く．}
\begin{equation}
\mathList{z}=\mathList{x}\mathListConcat\mathList{y}
\end{equation}

関数はリストを受け取ることができる．次の書き方では，関数$f$は整数リストの最初の要素$x$と残りの要素$\mathList{x}$を別々に受け取り，先頭要素だけを返す．\footnote{\haskell では \verb|f (x:xs) :: [Int] -> Int = x| と書く．}
\begin{gather}
f\mathTypeIs\mathTypeFunction{\mathTypeList{\mathTypeInt}}{\mathTypeInt}\\
f(x:\mathList{x})=x
\end{gather}

% x:y:ys

\section{内包表記}

リストの構成には\keyword{内包表記}が使える．例を挙げる．\footnote{\haskell では次のように書く．
\begin{footcode}
      xs = [x^2 | x <- [1, 2..100], x>50]
\end{footcode}}
\begin{equation}
\mathList{x}=\mathMakeListComplehention{x^2}{x\mathIn\mathMakeList{1,2\dots100},\mathEven x}
\end{equation}
この例では数列$\mathMakeList{1,2\dots100}$のうち偶数だけを2乗したリストを作っている．

\section{文字列}

文字型のリストを文字列型と呼び$\mathTypeString$で表す．$\mathTypeString$型は次のように予約語$\mathKeyword{type}$を用いて，\keyword{型シノニム}すなわち型の別名として次のように定義される．
\begin{equation}
\mathTypeSynonim{\mathTypeString}{\mathTypeList{\mathTypeChar}}
\end{equation}

文字列型のリテラルは次のように書く．\footnote{\haskell では \verb|xs = "Hello, World!"| と書く．}
\begin{equation}
\mathString{x}=\mathLiteralString{Hello, World!}
\end{equation}

\tobewritten{Stringに関する有名な関数．}

\section{マップと畳み込み}

リスト$\mathList{x}$の各要素に関数$f$を適用して，その結果をリスト$\mathList{z}$に格納するためには次のように\keyword{マップ演算子}$\mathMap$を用いる．\footnote{\haskell では \verb|zs = f `map` xs| と書く．}
\begin{equation}
\mathList{z}=f\mathMap\mathList{x}
\label{eq:map}
\end{equation}
式\eqref{eq:map}は次の式と同じである．\footnote{\haskell では \verb/zs = [f x | x <- xs]/ と書く．}
\begin{equation}
\mathList{z}=\mathMakeListComplehention{fx}{x\mathIn\mathList{x}}
\end{equation}

リスト$\mathList{x}$の各要素を先頭から順番に二項演算子を適用して，その結果を得るには畳み込み演算子を用いる．たとえば整数リストの和は次のように書ける．\footnote{\haskell では \verb|z = foldl 0 (+) xs| と書く．}
\begin{equation}
z=\mathFold{0}{(\mathAnonymousParameter+\mathAnonymousParameter)}\mathList{x}
\end{equation}
\haskell では
\begin{equation}
\mathSum=\mathFold{0}{(\mathAnonymousParameter+\mathAnonymousParameter)}
\end{equation}
として関数$\mathSum$が定義されている．\footnote{\haskell では関数$\mathSum$を \verb|sum| と書く．}

リスト$\mathList{x}$が$\mathList{x}=[x_0,x_1,\dots,x_n]$のとき，一般に
\begin{equation}
\mathFold{a}{\mathAnonymousParameter\mathAnonymousOperator\mathAnonymousParameter}{\mathList{x}}
=a\mathAnonymousOperator x_0\mathAnonymousOperator x_1\dots x_{n-1}\mathAnonymousOperator x_n
\end{equation}
である．

畳み込み演算子には次の右結合バージョンが存在する．\footnote{\haskell では \verb|foldr| を用いる．}
\begin{equation}
\mathFoldRight{a}{\mathAnonymousParameter\mathAnonymousOperator\mathAnonymousParameter}{\mathList{x}}
=a\mathAnonymousOperator\left(x_0\dots\left(x_{n-2}\mathAnonymousOperator\left(x_{n-1}\mathAnonymousOperator x_n\right)\right)\right)
\end{equation}

\section{IOサバイバルキット2}

1行ごとに3次元ベクトルが並べられた，以下の入力ファイルがあるとする．
\begin{sourcecode}{input.txt}
\begin{verbatim}
1.0 2.0 3.0
4.5 5.5 6.5
\end{verbatim}
\end{sourcecode}
このようなファイル形式は計算機科学者にとって見慣れたものである．

各行つまり各ベクトルごとに，そのノルムを計算して出力するプログラムを書きたいとしよう．まず数列を受け取ってそのノルムを返す関数$\mathNorm$を次のように定義する．\footnote{\haskell では次のように書く．
\begin{footcode}
      norm :: [Double] -> Double
      norm [] = 0.0
      norm xs = sqrt $ sum [x * x | x <- xs]
\end{footcode}}
\begin{align}
\mathNorm&\mathTypeIs\mathTypeFunction{\mathTypeList{\mathTypeReal}}{\mathTypeReal}\\
\mathNorm[]&=0.0\\
\mathNorm\mathList{x}&=\mathSqrt\mathApply\mathSum\mathMakeListComplehention{x*x}{x\mathIn\mathList{x}}
\end{align}

入力ファイル全体を受け取るにはアクション$\textsl{getContents}$を用いる．入力ファイルを1行毎のリストにするには関数$\textrm{lines}$を用いる．

各行を空白で区切ってリストに格納するには関数$\mathWords$を用いる．

各文字列を数に変換するには次の関数$\mathRead_{\mathTypeReal}\mathTypeIs\mathTypeFunction{\mathTypeString}{\mathTypeReal}$を用いる．\footnote{\haskell では次のように書く．
\begin{footcode}
      readDouble :: String -> Double
      readDouble = read
\end{footcode}}
\begin{align}
\mathRead_{\mathTypeReal}&\mathTypeIs\mathTypeFunction{\mathTypeString}{\mathTypeReal}\\
\mathRead_{\mathTypeReal}&=\mathRead
\end{align}

入力ファイルの各行に書かれたベクトルを対象に関数$\mathNorm$を適用して，結果を書き出すには次のように書く．\footnote{\haskell では次のように書く．
\begin{footcode}
      main = print 
        . (norm <$>) 
        . ((readDouble <$>) <$>) 
        . (words <$>) 
        . lines 
        =<< getContents
\end{footcode}}
\begin{multline}
\mathMain=\mathPrint
\mathCompose(\mathNorm\mathMap)
\mathCompose((\mathRead_{\mathTypeReal}\mathMap)\mathMap)\\
\mathCompose(\mathWords\mathMap)
\mathCompose\mathLines
\mathBind\mathGetContents
\end{multline}

アクション$\mathPrint$に代えて次の$\mathPrintEach$を用いると，入力と出力を同じ形式にできる．\footnote{\haskell では \verb|printEach xs = print `mapM` xs| と書く．}
\begin{equation}
\mathPrintEach\mathList{x}=\mathPrint\mathMapM\mathList{x}
\end{equation}
演算子$\mathMapM$はアクション版のマップ演算子である．

\section{Maybe}

計算は失敗する可能性がある．例えば
\begin{equation}
z=y/x
\end{equation}
のときに$x\mathCompareEq0$であったとしたら，この計算は失敗する．プログラムが計算を失敗した場合，たいていのプログラマは大域ジャンプを試みる．しかし大域ジャンプは変数の書き換えを行うことであるから，別の方法が望まれる．\haskell では失敗する可能性がある場合にはMaybeという機構が使える．

いま関数$f$が引数$x$と$y$を取り，$x\neq0$であるならば$y/x$を返すとする．もし$x\mathCompareEq0$であれば失敗を意味する$\mathNothing$（ナッシング）を返すとする．すると関数$f$の定義は次のようになる．
\begin{equation}
fyx=\mathIf{x\neq0}{y/x}{\mathNothing}\dots\text{（不完全）}
\end{equation}
残念ながら上式は不完全である．なぜならば$x\neq0$のときの戻り値は数であるのに対して，$x\mathCompareEq0$のときの戻り値は数ではないからである．そこで
\begin{equation}
\mathMonadic{f}yx=\mathIf{x\neq0}{\mathMakeJust{y/x}}{\mathNothing}
\end{equation}
とする．ここに$\mathMakeJust{y/x}$は数$y/x$から作られる，Maybeで包まれた数である．
% ~fの理由．

整数型$\mathTypeInt$をMaybeで包む場合は$\mathTypeMaybe{\mathTypeInt}$と書く．Maybeで包まれた型を持つ変数は$\mathMaybe{x}$のように小さく$?$をつける．例を挙げる．\footnote{\haskell では \verb|xm :: Maybe Int| と書く．}
\begin{equation}
\mathMaybe{x}\mathTypeIs\mathTypeMaybe{\mathTypeInt}
\end{equation}

Maybeで包まれた型を持つ変数は，値を持つか$\mathNothing$（ナッシング）であるかのいずれかである．値をもつ場合は
\begin{equation}
\mathMaybe{x}=\mathMakeJust{1}
\end{equation}
のように書く．\footnote{\haskell では \verb|xm = Just 1| と書く．}

Maybe変数が値を持たない場合は
\begin{equation}
\mathMaybe{x}=\mathNothing
\end{equation}
と書く．\footnote{\haskell では \verb|xm = Nothing| と書く．}

\section{Maybeに対する計算}

Maybe変数に，非Maybe変数を受け取る関数を適用することは出来ない．そこで特別な演算子$\mathFMap$を用いる．\footnote{\haskell では \verb|zm = (+1) <$> xm| と書く．}
\begin{equation}
\mathMaybe{z}=(\mathAnonymousParameter+1)\mathFMap\mathMaybe{x}
\end{equation}
ここに演算子$\mathFMap$は
\begin{align}
\mathMakeJust{fx}&=f\mathFMap\mathMakeJust{x}\\
\mathNothing&=f\mathFMap\mathNothing
\end{align}
と定義される．

\section{Maybeの中のリスト}

リストがMaybeの中に入っている場合は，リストの各要素に関数を適用することができる．例を挙げる．
\begin{equation}
\mathMaybe{x}=\mathMakeJust{[1,2,\dots,100]}
\end{equation}
のとき，リストの各要素に関数$f\mathTypeIs\mathTypeFunction{\mathTypeInt}{\mathTypeInt}$を適用するには次のように書く．\footnote{\haskell では \verb|zm = (f <$>) <$> xm| と書く．最初の \verb|<$>| はリストの各要素に関数$f$を適用する演算子，2番目の \verb|<$>| はMaybeの中のリストの各要素に関数$f$を適用する演算子である．}
\begin{equation}
\mathMaybe{z}=(f\mathMap)\mathFMap\mathMaybe{x}
\end{equation}

\section{型パラメタ}

型をパラメタとして扱うことができる．任意の型を$\mathTypeGeneral{a}$と，ボールド体小文字で書く．ある型$\mathTypeGeneral{a}$の引数を取り，同じ型を返す関数の型は次のように書ける．\footnote{\haskell では \verb|f :: a -> a| と書く．}
\begin{equation}
f\mathTypeIs\mathTypeFunction{\mathTypeGeneral{a}}{\mathTypeGeneral{a}}
\end{equation}

\keyword{型パラメタ}には制約をつけることができる．型の集合を\keyword{型クラス}と呼び，フラクチュール体で書く．たとえば数を表す型クラスは$\mathClassNum$である．型パラメタ$\mathTypeGeneral{a}$が型クラス$\mathClassNum$に属するとき，上述の関数$f$の型注釈は次のようになる．\footnote{\haskell では \verb|f :: Num a => a -> a| と書く．}
\begin{equation}
f\mathTypeIs
  \mathTypeClass{\mathClassNum}
    {\mathTypeGeneral{a}}
    {\mathTypeFunction{\mathTypeGeneral{a}}{\mathTypeGeneral{a}}}
\end{equation}

型クラスは型に制約を与える．

\tobewritten{\texttt{Num a => x :: a} ならば\texttt{x}が持つべき演算子．}

\tobewritten{型クラスの例．}

\section{関手}

型$\mathTypeGeneral{a}$のリストの変数は
\begin{equation}
\mathList{x}\mathTypeIs\mathTypeList{\mathTypeGeneral{a}}
\end{equation}
という型注釈を持つ．これは
\begin{equation}
\mathList{x}\mathTypeIs\mathFunctorTypeGeneral{[]}{\mathTypeGeneral{a}}
\end{equation}
のシンタックスシュガーである．

型$\mathTypeGeneral{a}$型のMaybeの変数は
\begin{equation}
\mathMaybe{x}\mathTypeIs\mathTypeMaybe{\mathTypeGeneral{a}}
\end{equation}
という型注釈を持つ．

普段遣いの関数
\begin{equation}
f\mathTypeIs\mathTypeFunction{\mathTypeGeneral{a}}{\mathTypeGeneral{a}}
\end{equation}
をリスト変数$\mathList{x}$に適用する場合は
\begin{equation}
\mathList{z}=f\mathMap\mathList{x}
\end{equation}
とする．同じく関数$f$をMaybe変数$\mathMaybe{x}$に適用する場合は
\begin{equation}
\mathMaybe{z}=f\mathFMap\mathMaybe{x}
\end{equation}
とする．

リストもMaybeも元の型$\mathTypeGeneral{a}$から派生しており，関数適用のための特別な演算子を持つことになる．そこで，リストやMaybeは\keyword{関手}という型クラスに属する，型パラメタを伴う型であるとする．関手の型クラスを$\mathClassFunctor$で表す．関手型クラスの$\mathTypeGeneral{a}$型の変数を次のように型注釈する．\footnote{\haskell では \verb|xm :: Functor f => f a| と書く．}
\begin{equation}
\mathPure{x}\mathTypeIs
  \mathTypeClass{\mathClassFunctor}
    {\mathClassGeneral{f}}
    {\mathFunctorTypeGeneral{\mathClassGeneral{f}}{\mathTypeGeneral{a}}}
\end{equation}

型クラス$\mathClassFunctor$に属する型は$\mathFMap$演算子を持たねばならない．演算子$\mathFMap$は次の形を持つ．\footnote{In \haskell, \verb|zm = f <$> xm|.}
\begin{equation}
\mathPure{z}=f\mathFMap\mathPure{x}
\end{equation}
演算子$\mathFMap$の型は次のとおりである．
\begin{equation}
\mathAnonymousParameter\mathFMap\mathAnonymousParameter
  \mathTypeIs\mathTypeFunctionII{\left(\mathTypeFunction{\mathTypeGeneral{a}}{\mathTypeGeneral{b}}\right)}
    {\mathFunctorTypeGeneral{\mathClassGeneral{f}}{\mathTypeGeneral{a}}}
    {\mathFunctorTypeGeneral{\mathClassGeneral{f}}{\mathTypeGeneral{b}}}
\end{equation}

もし変数$\mathPure{x}$の型がリストであれば
\begin{equation}
\mathFMap=\mathMap
\end{equation}
であると解釈する．

Function of parametric type with functor class:\footnote{In \haskell, \verb|f :: Functor f => a -> f a|.}
\begin{equation}
f\mathTypeIs
  \mathTypeClass{\mathClassFunctor}
    {\mathClassGeneral{f}}
    {\mathTypeFunction{\mathTypeGeneral{a}}
      {\mathFunctorTypeGeneral{\mathClassGeneral{f}}{\mathTypeGeneral{a}}}}
\end{equation}


Example function application:\footnote{In \haskell, \verb|zm = (+1) <$> Just x|.}
\begin{equation}
\mathPure{z}=(\mathAnonymousParameter+1)\mathFMap\mathMakeJust{x}
\end{equation}

\section{関手としての関数}

\begin{equation}
f\mathTypeIs\mathTypeFunction{\mathTypeGeneral{q}}{\mathTypeGeneral{r}}
\end{equation}

Function as a functor:\footnote{In \haskell, \verb|f :: ((->) r) q|.}
\begin{equation}
f\mathTypeIs\left(\mathTypeFunction{\mathAnonymousTypeParameter}{\mathTypeGeneral{r}}\right)\mathTypeGeneral{q}
=\mathFunctorTypeGeneral{\left(\mathTypeFunction{\mathAnonymousTypeParameter}{\mathTypeGeneral{r}}\right)}
  {\mathTypeGeneral{q}}
\end{equation}

Thus,
\begin{equation}
f_2\mathCompose f_1\equiv f_2\mathFMap f_1
\end{equation}

\begin{align}
\mathId\mathCompose f&=\mathId f=f\\
(h\mathCompose g)\mathCompose f&=((h\mathCompose)\mathCompose(g\mathCompose))f\\
&=h\mathCompose(g\mathCompose f)
\end{align}

\section{アプリカティブ関手}

Pure:\footnote{In \haskell, \verb|zm = pure x|.}
\begin{equation}
\mathPure{z}=\mathMakePure{x}
\end{equation}

% Pure is not pure.

Applicative map:\footnote{In \haskell, \verb|zm = f <*> xm|.}
\begin{equation}
\mathPure{z}=\mathPure{f}\mathApplicativeMap\mathPure{x}
\end{equation}
where
\begin{equation}
\mathPure{f}\mathTypeIs
  \mathFunctorTypeGeneral{\mathTypeGeneral{f}}
  {\mathTypeFunction{\mathTypeGeneral{a}}{\mathTypeGeneral{b}}}
\end{equation}

Applicative style:\footnote{In \haskell, \verb|zm = pure (+) <*> xm <*> ym|.}
\begin{equation}
\mathPure{z}
  =\mathMakePure{f}
  \mathApplicativeMap\mathPure{x}
  \mathApplicativeMap\mathPure{y}
\end{equation}
or\footnote{In \haskell, \verb|zm = f <$> xm <*> ym|.}
\begin{equation}
\mathPure{z}
  =f
  \mathFMap\mathPure{x}
  \mathApplicativeMap\mathPure{y}
\end{equation}
or\footnote{In \haskell, \verb|zm = liftA2 f xm ym|. }
\begin{equation}
\mathPure{z}=\mathApplicativeFuncCall{f\,\mathPure{x}\,\mathPure{y}}
\end{equation}


\section{モナド}

Returning \emph{List}.
\begin{equation}
	.
\end{equation}
Returning \emph{Maybe}:\footnote{In \haskell, \verb|f :: Int -> Maybe Int| and \verb|f x = Just x|.}
\begin{align}
f&\mathTypeIs\mathTypeFunction{\mathTypeInt}{\mathTypeMaybe{\mathTypeInt}}\\
fx&=\mathMakeJust{x}
\end{align}
% Applicative.
Returning \emph{monad}:
\begin{align}
f&\mathTypeIs
  \mathTypeFunction{\mathTypeInt}{\mathFunctorTypeGeneral{\mathClassGeneral{m}}{\mathTypeGeneral{a}}}\\
fx&=\mathMakeReturn{x}
\end{align}


Returning monadic value:\footnote{In \haskell, \verb|f :: Monad m => a -> m a|.}
\begin{equation}
f\mathTypeIs
  \mathTypeClass{\mathClassMonad}
    {\mathClassGeneral{m}}
    {\mathTypeFunction{\mathTypeGeneral{a}}{\mathFunctorTypeGeneral{\mathClassGeneral{m}}{\mathTypeGeneral{a}}}}
\end{equation}

Monadic function binding:\footnote{In \haskell, \verb|zm = xm >>= f1 >>= f2|.}
\begin{equation}
\mathPure{z}=\mathPure{x}\mathBindRight f_1\mathBindRight f_2
\end{equation}
where
\begin{align}
f_1&\mathTypeIs\mathTypeFunction{\mathTypeInt}{\mathTypeMaybe{\mathTypeInt}}\\
f_2&\mathTypeIs\mathTypeFunction{\mathTypeInt}{\mathTypeMaybe{\mathTypeInt}}.
\end{align}

Function binding of monadic function and non-monadic function:\footnote{In \haskell,
\begin{footcode}
zm = xm >>= f >>= g'
  where g' w = pure (g w)
\end{footcode}}
\begin{equation}
\mathPure{z}=\mathPure{x}\mathBindRight f\mathBindRight g'
\mathWhere{g'w=\mathMakePure{gw}}
\end{equation}
or
\begin{equation}
  \mathPure{z}=\mathPure{x}\mathBindRight(f\mathComposeMonadRight g')
  \mathWhere{g'w=\mathMakePure{gw}}
\end{equation}
where
\begin{align}
f&\mathTypeIs\mathTypeFunction{\mathTypeInt}{\mathTypeMaybe{\mathTypeInt}}\\
g&\mathTypeIs\mathTypeFunction{\mathTypeInt}{\mathTypeInt}.
\end{align}
Another solution is:
\begin{equation}
\mathPure{z}=(\mathLiftM{g}\mathCompose f)\mathBind\mathPure{x}
\end{equation}
where $\mathLiftM{g}$ means \verb|liftM g| in \haskell.\footnote{In \haskell, \verb|zm = (liftM g . f) xm|.}

\section{種}

\begin{equation}
\mathTypeFunction{\mathAnyKind}{\mathAnyKind}
\end{equation}

\section{Data}

Data:\footnote{In \haskell,
\begin{footcode}
data Suit = Spade | Heart | Club | Diamond
\end{footcode}}
\begin{equation}
\mathData{\mathTypeGeneral{Suit}}
  {\mathConstructor{Spade}\mathOr\mathConstructor{Heart}\mathOr\mathConstructor{Club}\mathOr\mathConstructor{Diamond}}
\end{equation}

Data with parameters:\footnote{In \haskell,
\begin{footcode}
data V2 = V2 { x :: Int, y :: Int}
\end{footcode}
or \verb|data V2 = V2 Int Int|.}
\begin{equation}
\mathData{\mathTypeGeneral{V^2}}
  {\mathConstructor{V^2}\left\{x\mathTypeIs\mathTypeInt,y\mathTypeIs\mathTypeInt\right\}}
\end{equation}

\section{型クラスとインスタンス}

\section{IOモナド}

IO example:\footnote{In \haskell, \verb|main = getLine >>= print >> return 0|.}
\begin{equation}
\mathMain=\mathGetLine\mathBindRight\mathPrint\mathNext\mathMakeReturn{0}
\end{equation}

\section{Do構文}

Do notation:\footnote{In \haskell, \verb|z = do {x' <- x; y' <- y; f x'; g y'}|.}
\begin{equation}
\mathPure{z}=\mathDo{x'\leftarrow\mathPure{x};y'\leftarrow\mathPure{y};fx';gy'}
\end{equation}

\dbend

\section{モノイド}

任意の関数$f$に対して
\begin{equation}
\mathId f=f
\end{equation}
なる関数$\mathId$があり，かつ任意の関数$f,g,h$に対して
\begin{equation}
(h\mathCompose g)\mathCompose f=h\mathCompose(g\mathCompose f)
\end{equation}
が成り立つとする．このとき関数は\keyword{モノイド}であるという．

\tobewritten{一般のモノイド．}

\section{モノイド則}
型$\mathTypeGeneral{a}$の変数$x,y,z\mathTypeIs\mathTypeGeneral{a}$について，特別な変数$\mathIdentity\mathTypeIs\mathTypeGeneral{a}$および二項演算子$\mathAnyBinaryOperator$ただし$x\mathAnyBinaryOperator y\mathTypeIs\mathTypeGeneral{a}$があり，
\begin{align}
\mathIdentity\mathAnyBinaryOperator x&=x\dots\text{（単位元の存在）}\\
(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z&=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)\dots\text{（結合律）}
\end{align}
であるとき，組み合わせ$(\mathTypeGeneral{a},\mathAnyBinaryOperator,\mathIdentity)$をモノイドと呼ぶ．

組み合わせ$(\mathTypeInt,+,0)$や$(\mathTypeInt,\times,1)$はモノイドである．

同じ型から同じ型への1引数関数を改めて$\mathTypeFunction{\mathTypeGeneral{a}}{\mathTypeGeneral{a}}$で表し，特別な変数$\mathIdentity$を関数$\mathId$，二項演算子を$\mathCompose$とすると以下の関係が成り立つ．
\begin{align}
\mathId\mathCompose f&=f\dots\text{（単位元の存在）}\\
(h\mathCompose g)\mathCompose f&=h\mathCompose(g\mathCompose f)\dots\text{（結合律）}
\end{align}
そこで組み合わせ$(\mathTypeFunction{\mathTypeGeneral{a}}{\mathTypeGeneral{a}},\mathCompose,\mathId)$はモノイドであると言える．

\section{関手則}

関手のマップ演算子$\mathFMap$は以下の\keyword{関手則}に従う．
\begin{align}
\mathId\mathFMap\mathPure{x}&=\mathId\mathPure{x}\\
(g\mathCompose f)\mathFMap\mathPure{x}&=((g\mathFMap)\mathCompose(f\mathFMap))\mathPure{x}\\
&=g\mathFMap(f\mathFMap\mathPure{x})
\end{align}

関手則は\keyword{関手（数学）}に由来する．

\keyword{圏}$\mathCategory{C}$の\keyword{対象}を$\mathObject{X}$とする．圏$\mathCategory{D}$の対象は関手（数学）$\mathFunctor{F}$によって対象$\mathObject{X}$と関係づけられる．圏$\mathCategory{C}$における\keyword{射}$f:\mathObject{X}\rightarrow\mathObject{Y}$が$\mathFunctor{F}f:\mathFunctor{F}\mathObject{X}\rightarrow\mathFunctor{F}\mathObject{Y}$に対応し，次の関係を満たす．
\begin{itemize}
\item $\mathObject{X}\in\mathCategory{C}$に対して$\mathFunctor{F}\mathId_{\mathObject{X}}=\mathId_{\mathFunctor{F}\mathObject{X}}$
\item $f:\mathObject{X}\rightarrow\mathObject{Y}$および$g:\mathObject{Y}\rightarrow\mathObject{Z}$に対して$\mathFunctor{F}(g\mathCompose f)=(\mathFunctor{F}g)\mathCompose(\mathFunctor{F}f)$
\end{itemize}

いま
\begin{align}
\mathId_{\mathObject{X}},\mathId_{\mathFunctor{F}\mathObject{X}}&\rightarrow\mathId\\
f\mathFMap&\rightarrow\mathFunctor{F}f
\end{align}
と対応付けると，関手（数学）が満たす法則と関手則は一致する．

\section{アプリカティブ関手則}

アプリカティブ関手のマップ演算子$\mathApplicativeMap$は以下の規則に従う．
\begin{align}
\mathMakePure{\mathId}\mathApplicativeMap\mathPure{x}&=\mathPure{x}\\
\mathMakePure{f}\mathApplicativeMap\mathMakePure{x}&=\mathMakePure{fx}\\
\mathPure{f}\mathApplicativeMap\mathMakePure{x}&=\mathMakePure{\mathAnonymousParameter\mathApply x}\mathApplicativeMap\mathPure{f}\\
\mathMakePure{\mathAnonymousParameter\mathCompose\mathAnonymousParameter}\mathApplicativeMap\mathPure{h}\mathApplicativeMap\mathPure{g}\mathApplicativeMap\mathPure{f}
&=\mathPure{h}\mathApplicativeMap(\mathPure{g}\mathApplicativeMap\mathPure{f})
\end{align}

\section{モナド則}

モナドのマップ演算子$\mathBind$は以下の規則に従う．
\begin{align}
\mathMonadic{f}\mathBind\mathMakeReturn{x}&=\mathMonadic{f}x\\
\mathMakeReturn{\mathAnonymousParameter}\mathBind\mathPure{x}&=\mathPure{x}\\
(\mathMonadic{g}\mathBind\mathMonadic{f})\mathBind\mathPure{x}&=\mathMonadic{g}\mathBind(\mathMonadic{f}\mathBind\mathPure{x})
\end{align}
% つまり，組み合わせ$(\mathTypeFunction{\mathTypeGeneral{a}}{\mathFunctorTypeGeneral{\mathTypeGeneral{m}}{\mathTypeGeneral{a}}},\mathMakePure{\mathAnonymousParameter},\mathBind)$はモノイドである． -- bindの両辺の型が一致しないのでモノイドではない．

次の\keyword{クライスリスター}すなわち
\begin{equation}
\mathKleisliStar{f}=(\mathMonadic{f}\mathBind\mathAnonymousParameter)
\end{equation}
を用いると，モナド則は次のように書き換えられる．
\begin{align}
\left(\mathKleisliStar{f}\right)\mathMakePure{x}&=\mathMonadic{f}x\\
\mathKleisliStar{\left(\mathMakePure{\mathAnonymousParameter}\right)}\mathPure{x}&=\mathPure{x}\\
\mathKleisliStar{\left(\mathKleisliStar{g}\mathMonadic{f}\right)}\mathPure{x}&=\mathKleisliStar{g}\left(\mathKleisliStar{f}\mathPure{x}\right)
\end{align}

% \begin{tikzpicture}[nodes = {text depth = 1ex, text height = 2ex}]
%   \graph{ tex -> dvi -> ps -> pdf,
%   bib -> bbl,
%   bbl -> dvi};
% \end{tikzpicture}


% http://walk.northcol.org/haskell/monads/

% 正格評価
% https://kazu-yamamoto.hatenablog.jp/entry/20110413/1302683869

% returnの削除
% https://qiita.com/mod_poppo/items/8c483951703b5ea0f74e

% STモナド
% https://qiita.com/7shi/items/2e9bff5d88302de1a9e9

\end{document}
